

##  **1ï¸âƒ£ The Big Picture**

When writing **unit tests**, you want to test **only your code**, not your dependencies.

But what if your function calls:

* A **database** ğŸ—„ï¸
* A **network API** ğŸŒ
* A **file system** ğŸ“
* Or another **service** ğŸ”—

You donâ€™t want those to actually run â€” they make tests:

* Slow ğŸ¢
* Unreliable ğŸ˜µâ€ğŸ’«
* Dependent on network or data ğŸ’¥

So we replace them with **test doubles** like:
ğŸ‘‰ **stubs** and **mocks**

---

## ğŸ§  **2ï¸âƒ£ What Are Stubs and Mocks (Simple Definition)**

| Type        | Purpose                            | Behavior                           |
| ----------- | ---------------------------------- | ---------------------------------- |
| ğŸ§± **Stub** | *Provides fake data*               | You tell it what to return         |
| ğŸ­ **Mock** | *Checks how a dependency was used* | You verify it was called correctly |

---

## âš™ï¸ **3ï¸âƒ£ Example Scenario**

Letâ€™s say you have this function:

```ts
import { getUserFromDB, sendEmail } from "./services";

export function registerUser(email: string) {
  const user = getUserFromDB(email);
  if (user) throw new Error("User already exists");
  sendEmail(email, "Welcome!");
  return "Registration successful";
}
```

Here:

* `getUserFromDB` â†’ talks to a database
* `sendEmail` â†’ sends a real email

You donâ€™t want those running in your unit test âŒ
So weâ€™ll use **stubs and mocks**.

---

## ğŸ§± **4ï¸âƒ£ Using a Stub**

A **stub** replaces a real function with a fake one that just returns what we tell it to.

```ts
import { registerUser } from "../app/registerUser";
import * as services from "../app/services";

test("registers a new user when user doesn't exist", () => {
  // Stub DB call â†’ simulate user not found
  jest.spyOn(services, "getUserFromDB").mockReturnValue(null);

  // Stub email â†’ no actual email sent
  jest.spyOn(services, "sendEmail").mockImplementation(() => {});

  const result = registerUser("test@example.com");

  expect(result).toBe("Registration successful");
});
```

âœ… **Stub advantages:**

* No real DB/email used
* Test runs fast and isolated
* You control the fake data
* Focus stays on your logic

---

## ğŸ­ **5ï¸âƒ£ Using a Mock**

A **mock** not only fakes the function â€” it also **records how it was called** so you can verify behavior.

```ts
test("should send welcome email after registration", () => {
  jest.spyOn(services, "getUserFromDB").mockReturnValue(null);
  const emailMock = jest.spyOn(services, "sendEmail").mockImplementation(() => {});

  registerUser("hello@dwelzo.com");

  // Assert it was called with right arguments
  expect(emailMock).toHaveBeenCalledWith("hello@dwelzo.com", "Welcome!");
});
```

âœ… **Mock advantages:**

* Verify **behavior** (was it called?)
* Verify **arguments**
* Ensure **order of calls** if needed

---

## ğŸ§© **6ï¸âƒ£ Difference Between Stub and Mock (Quick Summary)**

| Feature     | Stub                  | Mock                     |
| ----------- | --------------------- | ------------------------ |
| Purpose     | Provide data          | Verify interactions      |
| Focus       | Output                | Behavior                 |
| Example use | Fake DB or API return | Check if email sent      |
| Assertion   | On result             | On function call         |
| Jest method | `mockReturnValue()`   | `toHaveBeenCalledWith()` |

---

## ğŸ§­ **7ï¸âƒ£ Why â€œUse Stubs and Mocks Wiselyâ€?**

Because **overusing** them causes trouble âš ï¸

### âŒ **Over-Mocking Problems**

| Issue                  | Description                                            |
| ---------------------- | ------------------------------------------------------ |
| ğŸ’¥ Fragile tests       | Change in code breaks test even if logic still correct |
| ğŸ˜µâ€ğŸ’« False confidence | You test mocks, not real behavior                      |
| ğŸ¢ Slow tests          | Too many dependencies mocked                           |
| ğŸ§© Hard maintenance    | Mocks everywhere, unclear real flow                    |

---

### âœ… **Wise Usage Guidelines**

| Rule                                         | Description                                                |
| -------------------------------------------- | ---------------------------------------------------------- |
| ğŸ¯ Mock only external dependencies           | API calls, DB, file I/O                                    |
| ğŸš« Donâ€™t mock what you own                   | Pure functions, helpers â€” test them directly               |
| ğŸ” Reset mocks each test                     | `afterEach(() => jest.clearAllMocks());`                   |
| ğŸ§± Use stubs for *data setup*                | When you just need fake data                               |
| ğŸ•µï¸â€â™‚ï¸ Use mocks for *behavior verification* | When you need to ensure a call was made                    |
| ğŸ§¹ Keep tests readable                       | Prefer descriptive mock names                              |
| ğŸ§ª Combine with edge cases                   | Test both success and failure paths                        |
| âš™ï¸ Mock async correctly                      | `mockResolvedValue()` / `mockRejectedValue()` for promises |

---

## âš™ï¸ **8ï¸âƒ£ Example of Bad vs. Good**

### âŒ Bad (Over-mocking)

```ts
jest.spyOn(Math, "max").mockReturnValue(10); // no need to mock built-ins
```

### âœ… Good

```ts
jest.spyOn(api, "fetchData").mockResolvedValue({ id: 1 });
```

Only mock whatâ€™s **external** and **unreliable**.

---

## ğŸ§© **9ï¸âƒ£ Real-Life Analogy**

* **Stub:** Like a **fake waiter** who always tells you â€œWe have pizza todayâ€ â€” predictable answer.
* **Mock:** Like a **restaurant manager** who checks if the waiter asked customers for their order â€” verifies behavior.

You use them so you donâ€™t depend on the *real kitchen* while testing your service flow ğŸ•

---

## ğŸ§  **ğŸ”Ÿ Summary Table**

| Concept    | Meaning                             | When to Use                                      |
| ---------- | ----------------------------------- | ------------------------------------------------ |
| Stub       | Fake returns fixed data             | When testing logic that depends on external data |
| Mock       | Records and verifies function calls | When testing if something *was called* correctly |
| Use Wisely | Only for dependencies, not own code | Keep tests simple, isolated, reliable            |

---

