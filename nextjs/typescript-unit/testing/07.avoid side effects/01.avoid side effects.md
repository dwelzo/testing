## **1️⃣ What Are Side Effects?**

👉 A **side effect** is **any change your function makes outside itself** — something that affects the _outside world_ or global state.

In other words:

> A “side effect” happens when a function **does more than just return a value**.

---

### 🎯 **Example (with side effect)**

```ts
let counter = 0;

function increment() {
  counter++; // modifies global variable → side effect
  return counter;
}
```

Every time you call `increment()`, it **changes global state** (`counter` variable).
So this function has a **side effect**.

---

### 🎯 **Example (no side effect)**

```ts
function add(a: number, b: number): number {
  return a + b; // pure function — no external change
}
```

✅ It depends only on inputs
✅ It doesn’t modify anything else
✅ It always gives the same output for the same inputs

---

## ⚙️ **2️⃣ Why Avoid Side Effects in Unit Tests?**

Because **side effects make tests unreliable** and **hard to isolate**.

| Problem            | Description                                  |
| ------------------ | -------------------------------------------- |
| 😵‍💫 Hard to predict | Tests depend on external or shared state     |
| 🔁 Non-repeatable  | Test might pass once, fail next run          |
| 🧩 Not isolated    | One test’s change affects another            |
| 🧱 Slow tests      | Waiting for DB, network, or file system      |
| 🪲 Hidden bugs     | Failures appear unrelated to the tested unit |

---

## 🧠 **3️⃣ Common Sources of Side Effects**

| Type                    | Example                                |
| ----------------------- | -------------------------------------- |
| 🗄️ **Database writes**  | Inserting data during test             |
| 🌐 **Network calls**    | Fetching API data                      |
| 🧾 **File operations**  | Writing to disk                        |
| ⏰ **Timers**           | Using `setTimeout`, `Date.now()`       |
| 🎛️ **Global variables** | Modifying global or shared state       |
| 🧍‍♂️ **DOM manipulation** | Changing UI in browser tests           |
| 🧩 **Mutable inputs**   | Changing input objects inside function |

---

## 🚫 **4️⃣ Example of Bad Test (with side effect)**

```ts
let users: string[] = [];

function addUser(name: string) {
  users.push(name); // changes external array
}

test("adds a user", () => {
  addUser("Mahesh");
  expect(users.length).toBe(1); // depends on global variable
});
```

🧨 **Problem:**
If another test also modifies `users`, your test results depend on **run order** — not good.

---

## ✅ **5️⃣ Correct Way — Avoid Side Effects**

Refactor function to **avoid mutating external state**.

```ts
function addUser(users: string[], name: string): string[] {
  return [...users, name]; // returns new array instead
}

test("adds a user", () => {
  const result = addUser([], "Mahesh");
  expect(result).toEqual(["Mahesh"]);
});
```

✅ Pure function
✅ No global dependency
✅ Same result every time
✅ Easy to test

---

## 🧱 **6️⃣ Other Examples of Avoiding Side Effects**

### ❌ Bad (API call inside function)

```ts
async function getUser() {
  const res = await fetch("https://api.example.com/user/1");
  return await res.json();
}
```

✅ Good (inject dependency)

```ts
async function getUser(apiClient: any) {
  return await apiClient.get("/user/1");
}
```

Then you can mock `apiClient` in your test:

```ts
test("fetches user", async () => {
  const mockClient = { get: jest.fn().mockResolvedValue({ name: "Alice" }) };
  const user = await getUser(mockClient);
  expect(user.name).toBe("Alice");
});
```

---

## 🧪 **7️⃣ Concept: Pure Function**

A **pure function** is one that:

1. Has **no side effects**
2. Depends only on its **inputs**
3. Always produces the **same output** for the same inputs

That’s the ideal type of function for unit testing.

Example:

```ts
function multiply(a: number, b: number): number {
  return a * b;
}
```

---

## 📊 **8️⃣ Why Isolation Matters**

Unit tests should test **only one thing** — the logic of that unit.
If it also hits:

- Database 🗄️
- Network 🌐
- File system 📁

then it’s no longer a “unit test”, it’s an **integration test**.

---

## 🧭 **9️⃣ How to Avoid Side Effects**

| Strategy              | Description                            |
| --------------------- | -------------------------------------- |
| ✅ Use pure functions | No global or external changes          |
| 🧪 Mock dependencies  | Fake APIs, DBs, timers                 |
| 🧹 Reset state        | Use `beforeEach()` or `afterEach()`    |
| 🧩 Immutable data     | Don’t mutate inputs; clone instead     |
| 🔍 Avoid randomness   | Mock `Math.random()` or `Date.now()`   |
| 🧱 No real network    | Use `nock` or `msw` to mock HTTP calls |

---

## 🧠 **10️⃣ Summary Table**

| Concept        | Meaning                                           |
| -------------- | ------------------------------------------------- |
| Side effect    | Anything a function does beyond returning a value |
| Avoid because  | Makes tests flaky and dependent on environment    |
| Goal           | Pure, isolated, repeatable tests                  |
| Fix            | Refactor + mock external dependencies             |
| Ideal Function | Same output for same input, no outside change     |

---

### 💬 Real-Life Analogy:

Imagine you’re testing a **light switch**.

- ✅ **Pure test:** You flip the switch, see if it sends an electric signal.
- ❌ **Side-effect test:** It turns on your whole house power and messes with other tests.

You want to test _just_ the switch, not everything it touches.
