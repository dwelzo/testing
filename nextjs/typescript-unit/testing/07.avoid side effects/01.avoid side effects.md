## **1ï¸âƒ£ What Are Side Effects?**

ğŸ‘‰ A **side effect** is **any change your function makes outside itself** â€” something that affects the _outside world_ or global state.

In other words:

> A â€œside effectâ€ happens when a function **does more than just return a value**.

---

### ğŸ¯ **Example (with side effect)**

```ts
let counter = 0;

function increment() {
  counter++; // modifies global variable â†’ side effect
  return counter;
}
```

Every time you call `increment()`, it **changes global state** (`counter` variable).
So this function has a **side effect**.

---

### ğŸ¯ **Example (no side effect)**

```ts
function add(a: number, b: number): number {
  return a + b; // pure function â€” no external change
}
```

âœ… It depends only on inputs
âœ… It doesnâ€™t modify anything else
âœ… It always gives the same output for the same inputs

---

## âš™ï¸ **2ï¸âƒ£ Why Avoid Side Effects in Unit Tests?**

Because **side effects make tests unreliable** and **hard to isolate**.

| Problem            | Description                                  |
| ------------------ | -------------------------------------------- |
| ğŸ˜µâ€ğŸ’« Hard to predict | Tests depend on external or shared state     |
| ğŸ” Non-repeatable  | Test might pass once, fail next run          |
| ğŸ§© Not isolated    | One testâ€™s change affects another            |
| ğŸ§± Slow tests      | Waiting for DB, network, or file system      |
| ğŸª² Hidden bugs     | Failures appear unrelated to the tested unit |

---

## ğŸ§  **3ï¸âƒ£ Common Sources of Side Effects**

| Type                    | Example                                |
| ----------------------- | -------------------------------------- |
| ğŸ—„ï¸ **Database writes**  | Inserting data during test             |
| ğŸŒ **Network calls**    | Fetching API data                      |
| ğŸ§¾ **File operations**  | Writing to disk                        |
| â° **Timers**           | Using `setTimeout`, `Date.now()`       |
| ğŸ›ï¸ **Global variables** | Modifying global or shared state       |
| ğŸ§â€â™‚ï¸ **DOM manipulation** | Changing UI in browser tests           |
| ğŸ§© **Mutable inputs**   | Changing input objects inside function |

---

## ğŸš« **4ï¸âƒ£ Example of Bad Test (with side effect)**

```ts
let users: string[] = [];

function addUser(name: string) {
  users.push(name); // changes external array
}

test("adds a user", () => {
  addUser("Mahesh");
  expect(users.length).toBe(1); // depends on global variable
});
```

ğŸ§¨ **Problem:**
If another test also modifies `users`, your test results depend on **run order** â€” not good.

---

## âœ… **5ï¸âƒ£ Correct Way â€” Avoid Side Effects**

Refactor function to **avoid mutating external state**.

```ts
function addUser(users: string[], name: string): string[] {
  return [...users, name]; // returns new array instead
}

test("adds a user", () => {
  const result = addUser([], "Mahesh");
  expect(result).toEqual(["Mahesh"]);
});
```

âœ… Pure function
âœ… No global dependency
âœ… Same result every time
âœ… Easy to test

---

## ğŸ§± **6ï¸âƒ£ Other Examples of Avoiding Side Effects**

### âŒ Bad (API call inside function)

```ts
async function getUser() {
  const res = await fetch("https://api.example.com/user/1");
  return await res.json();
}
```

âœ… Good (inject dependency)

```ts
async function getUser(apiClient: any) {
  return await apiClient.get("/user/1");
}
```

Then you can mock `apiClient` in your test:

```ts
test("fetches user", async () => {
  const mockClient = { get: jest.fn().mockResolvedValue({ name: "Alice" }) };
  const user = await getUser(mockClient);
  expect(user.name).toBe("Alice");
});
```

---

## ğŸ§ª **7ï¸âƒ£ Concept: Pure Function**

A **pure function** is one that:

1. Has **no side effects**
2. Depends only on its **inputs**
3. Always produces the **same output** for the same inputs

Thatâ€™s the ideal type of function for unit testing.

Example:

```ts
function multiply(a: number, b: number): number {
  return a * b;
}
```

---

## ğŸ“Š **8ï¸âƒ£ Why Isolation Matters**

Unit tests should test **only one thing** â€” the logic of that unit.
If it also hits:

- Database ğŸ—„ï¸
- Network ğŸŒ
- File system ğŸ“

then itâ€™s no longer a â€œunit testâ€, itâ€™s an **integration test**.

---

## ğŸ§­ **9ï¸âƒ£ How to Avoid Side Effects**

| Strategy              | Description                            |
| --------------------- | -------------------------------------- |
| âœ… Use pure functions | No global or external changes          |
| ğŸ§ª Mock dependencies  | Fake APIs, DBs, timers                 |
| ğŸ§¹ Reset state        | Use `beforeEach()` or `afterEach()`    |
| ğŸ§© Immutable data     | Donâ€™t mutate inputs; clone instead     |
| ğŸ” Avoid randomness   | Mock `Math.random()` or `Date.now()`   |
| ğŸ§± No real network    | Use `nock` or `msw` to mock HTTP calls |

---

## ğŸ§  **10ï¸âƒ£ Summary Table**

| Concept        | Meaning                                           |
| -------------- | ------------------------------------------------- |
| Side effect    | Anything a function does beyond returning a value |
| Avoid because  | Makes tests flaky and dependent on environment    |
| Goal           | Pure, isolated, repeatable tests                  |
| Fix            | Refactor + mock external dependencies             |
| Ideal Function | Same output for same input, no outside change     |

---

### ğŸ’¬ Real-Life Analogy:

Imagine youâ€™re testing a **light switch**.

- âœ… **Pure test:** You flip the switch, see if it sends an electric signal.
- âŒ **Side-effect test:** It turns on your whole house power and messes with other tests.

You want to test _just_ the switch, not everything it touches.
