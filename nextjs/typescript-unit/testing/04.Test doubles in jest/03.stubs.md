**stubs.â€**

---

## ğŸ’¡ What is a Stub?

A **stub** is a **test double that provides controlled outputs** to your system under test.
Unlike a dummy (which does nothing), a stub **returns fake data** to help you test different scenarios **without using the real dependency**.

> Think of it as:
> â€œPretend to be the real thing â€” but only return what I tell you.â€

---

## ğŸ§© Example Setup

Letâ€™s use a simple case again.

### 1ï¸âƒ£ `emailService.ts`

```typescript
export class EmailService {
  sendEmail(to: string, subject: string, body: string): string {
    console.log(`ğŸ“§ Real Email sent to ${to}`);
    return "Email Sent Successfully";
  }
}
```

### 2ï¸âƒ£ `userService.ts`

```typescript
import { EmailService } from "./emailService";

export class UserService {
  constructor(private emailService: EmailService) {}

  registerUser(name: string, email: string) {
    if (!email) throw new Error("Email required");

    const result = this.emailService.sendEmail(email, "Welcome!", `Hi ${name}`);
    return result === "Email Sent Successfully"
      ? `User ${name} registered`
      : `Email failed`;
  }
}
```

---

## âŒ Without Stub (Real Dependency)

### `userService.noStub.test.ts`

```typescript
import { UserService } from "../app/userService";
import { EmailService } from "../app/emailService";

test("registerUser() without stub uses real email service", () => {
  const emailService = new EmailService(); // real one
  const userService = new UserService(emailService);

  const result = userService.registerUser("Alice", "alice@example.com");

  expect(result).toBe("User Alice registered");
});
```

ğŸ§  What happens:

* It runs `sendEmail()` for real.
* You canâ€™t control or simulate email failures.
* It depends on side effects (console logs or real API calls).

---

## âœ… With Stub

Weâ€™ll **replace `EmailService`** with a **stub** that returns what we want.

### `userService.stub.test.ts`

```typescript
import { UserService } from "../app/userService";
import { EmailService } from "../app/emailService";

// A stubbed version of EmailService
class StubEmailService extends EmailService {
  sendEmail(to: string, subject: string, body: string): string {
    return "Email Sent Successfully"; // controlled fake output
  }
}

test("registerUser() with stub simulates successful email", () => {
  const stubEmailService = new StubEmailService();
  const userService = new UserService(stubEmailService);

  const result = userService.registerUser("Bob", "bob@example.com");

  expect(result).toBe("User Bob registered");
});
```

ğŸ§  What happens:

* `sendEmail()` never logs anything or sends real emails.
* You control its return value.
* You can simulate both **success** and **failure** easily.

---

### ğŸ§ª Stub Example for Failure Case

```typescript
class FailingEmailServiceStub extends EmailService {
  sendEmail(): string {
    return "Error Sending Email"; // fake failure
  }
}

test("registerUser() with stub simulates email failure", () => {
  const stub = new FailingEmailServiceStub();
  const userService = new UserService(stub);

  const result = userService.registerUser("Charlie", "charlie@example.com");

  expect(result).toBe("Email failed");
});
```

âœ… Now your test can simulate **both success and failure**
without touching the real network or console.

---

## ğŸ§­ Difference Between Dummy and Stub

| Type      | Purpose               | Behavior                          |
| --------- | --------------------- | --------------------------------- |
| **Dummy** | Just a placeholder    | Does nothing, not used            |
| **Stub**  | Provide fixed outputs | Returns fake data to control flow |
| **Mock**  | Verify interactions   | Tracks calls and arguments        |

---

## ğŸ’¬ Summary

* Dummy = â€œJust pass me something.â€
* Stub = â€œPretend result = âœ… or âŒ.â€
* Mock = â€œIâ€™ll check if you called me correctly.â€

