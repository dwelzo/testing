

## 🕵️‍♂️ What is a “Spy” in Testing?

A **Spy** is like a **CCTV camera** 🎥 —
It **watches** a *real function* to check:

* Was it called?
* How many times?
* With what arguments?

Unlike a **mock**, a spy **doesn’t replace** the real function completely —
it **monitors** it (though you *can* make it fake behavior if you want).

---

## 🏠 Real-life Analogy

Imagine your mom wants to see if you actually studied 📚.
She installs a CCTV camera in your study room.
She doesn’t stop you from studying — she just **watches** when and how you do it.

That **camera = spy**
You **= real function**

---

## 🧩 TypeScript Example

### 📁 calculator.ts

```ts
export class Calculator {
  add(a: number, b: number) {
    return a + b;
  }

  multiply(a: number, b: number) {
    return a * b;
  }

  calculateTotal(a: number, b: number) {
    const sum = this.add(a, b);
    const result = this.multiply(sum, 2);
    return result;
  }
}
```

### 🧪 calculator.test.ts (with Jest Spy)

```ts
import { Calculator } from "../calculator";

test("should spy on add() and multiply() methods", () => {
  const calc = new Calculator();

  // 🕵️ Create spies to watch real functions
  const spyAdd = jest.spyOn(calc, "add");
  const spyMultiply = jest.spyOn(calc, "multiply");

  // 👇 Call main function
  const total = calc.calculateTotal(2, 3);

  // ✅ Check return
  expect(total).toBe(10);

  // 👀 Verify spies (like CCTV logs)
  expect(spyAdd).toHaveBeenCalledWith(2, 3);
  expect(spyMultiply).toHaveBeenCalledWith(5, 2);

  // 📋 Optional: check how many times
  expect(spyAdd).toHaveBeenCalledTimes(1);
  expect(spyMultiply).toHaveBeenCalledTimes(1);
});
```

---

## 🧠 What Happens Here

| Step | What happens                               | Why use Spy                            |
| ---- | ------------------------------------------ | -------------------------------------- |
| 1    | You call `calculateTotal(2,3)`             | Triggers both `add()` and `multiply()` |
| 2    | Spy **records** those function calls       | Like CCTV tracking your actions        |
| 3    | You check if the right numbers were passed | Ensures logic flow is correct          |

So instead of checking **output only**, you’re checking **behavior** (how the code worked internally).

---

## 🔄 Optional: Changing Spy Behavior

Sometimes, you may want your spy to “pretend” a different behavior.

```ts
test("should fake add() result using spy", () => {
  const calc = new Calculator();

  // 🧠 Spy and change behavior
  jest.spyOn(calc, "add").mockReturnValue(100);

  const total = calc.calculateTotal(2, 3);
  expect(total).toBe(200); // because multiply(100,2)

  // 👀 Still can check interactions
  expect(calc.add).toHaveBeenCalledWith(2, 3);
});
```

🪄 The spy **still records** calls but also **fakes** the result.

---

## 🧭 When to Use Spy in Real Projects

| Scenario                                  | Real-world use                    |
| ----------------------------------------- | --------------------------------- |
| **Controller calls service method**       | Verify service method is invoked  |
| **React component calls helper function** | Check handler was triggered       |
| **Backend function triggers logger**      | Spy on `logger.info()` to confirm |
| **Payment service calls API**             | Spy to ensure correct API args    |

---

## 💬 In short:

| Concept  | Meaning                      | Example                |
| -------- | ---------------------------- | ---------------------- |
| **Stub** | Fake a dependency’s response | Always returns “OK”    |
| **Mock** | Replace and verify behavior  | Check it was called    |
| **Spy**  | Watch a real function        | See if/how it was used |

---

### 🧠 One-line Summary

> 🕵️ A **Spy** watches a real function’s behavior — without replacing it.
> It’s perfect for verifying **internal calls** inside your logic.
\