

## ðŸ•µï¸â€â™‚ï¸ What is a â€œSpyâ€ in Testing?

A **Spy** is like a **CCTV camera** ðŸŽ¥ â€”
It **watches** a *real function* to check:

* Was it called?
* How many times?
* With what arguments?

Unlike a **mock**, a spy **doesnâ€™t replace** the real function completely â€”
it **monitors** it (though you *can* make it fake behavior if you want).

---

## ðŸ  Real-life Analogy

Imagine your mom wants to see if you actually studied ðŸ“š.
She installs a CCTV camera in your study room.
She doesnâ€™t stop you from studying â€” she just **watches** when and how you do it.

That **camera = spy**
You **= real function**

---

## ðŸ§© TypeScript Example

### ðŸ“ calculator.ts

```ts
export class Calculator {
  add(a: number, b: number) {
    return a + b;
  }

  multiply(a: number, b: number) {
    return a * b;
  }

  calculateTotal(a: number, b: number) {
    const sum = this.add(a, b);
    const result = this.multiply(sum, 2);
    return result;
  }
}
```

### ðŸ§ª calculator.test.ts (with Jest Spy)

```ts
import { Calculator } from "../calculator";

test("should spy on add() and multiply() methods", () => {
  const calc = new Calculator();

  // ðŸ•µï¸ Create spies to watch real functions
  const spyAdd = jest.spyOn(calc, "add");
  const spyMultiply = jest.spyOn(calc, "multiply");

  // ðŸ‘‡ Call main function
  const total = calc.calculateTotal(2, 3);

  // âœ… Check return
  expect(total).toBe(10);

  // ðŸ‘€ Verify spies (like CCTV logs)
  expect(spyAdd).toHaveBeenCalledWith(2, 3);
  expect(spyMultiply).toHaveBeenCalledWith(5, 2);

  // ðŸ“‹ Optional: check how many times
  expect(spyAdd).toHaveBeenCalledTimes(1);
  expect(spyMultiply).toHaveBeenCalledTimes(1);
});
```

---

## ðŸ§  What Happens Here

| Step | What happens                               | Why use Spy                            |
| ---- | ------------------------------------------ | -------------------------------------- |
| 1    | You call `calculateTotal(2,3)`             | Triggers both `add()` and `multiply()` |
| 2    | Spy **records** those function calls       | Like CCTV tracking your actions        |
| 3    | You check if the right numbers were passed | Ensures logic flow is correct          |

So instead of checking **output only**, youâ€™re checking **behavior** (how the code worked internally).

---

## ðŸ”„ Optional: Changing Spy Behavior

Sometimes, you may want your spy to â€œpretendâ€ a different behavior.

```ts
test("should fake add() result using spy", () => {
  const calc = new Calculator();

  // ðŸ§  Spy and change behavior
  jest.spyOn(calc, "add").mockReturnValue(100);

  const total = calc.calculateTotal(2, 3);
  expect(total).toBe(200); // because multiply(100,2)

  // ðŸ‘€ Still can check interactions
  expect(calc.add).toHaveBeenCalledWith(2, 3);
});
```

ðŸª„ The spy **still records** calls but also **fakes** the result.

---

## ðŸ§­ When to Use Spy in Real Projects

| Scenario                                  | Real-world use                    |
| ----------------------------------------- | --------------------------------- |
| **Controller calls service method**       | Verify service method is invoked  |
| **React component calls helper function** | Check handler was triggered       |
| **Backend function triggers logger**      | Spy on `logger.info()` to confirm |
| **Payment service calls API**             | Spy to ensure correct API args    |

---

## ðŸ’¬ In short:

| Concept  | Meaning                      | Example                |
| -------- | ---------------------------- | ---------------------- |
| **Stub** | Fake a dependencyâ€™s response | Always returns â€œOKâ€    |
| **Mock** | Replace and verify behavior  | Check it was called    |
| **Spy**  | Watch a real function        | See if/how it was used |

---

### ðŸ§  One-line Summary

> ðŸ•µï¸ A **Spy** watches a real functionâ€™s behavior â€” without replacing it.
> Itâ€™s perfect for verifying **internal calls** inside your logic.
\